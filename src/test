
import React, { useState,useEffect } from 'react'
import { Paper, Typography, TextField, Container, Grid } from '@material-ui/core'
import { makeStyles } from '@material-ui/core'
import InputUnit from './InputUnit';
import '../App.css'
import { Specs,Environment,Diameter } from '../data/data';


const InputContainer=()=> {

    const[specs,setSpecs]=useState(Specs)
    const[environment,setEnvironment]=useState(Environment)
    const[diameter,setDiameter]=useState(Diameter)

    // useEffect(()=>{

    //     specsChangeHandler(specs,data)
    //     environmentChangeHandler()
    //     diameterChangeHandler()
    // },[])

   const specsChangeHandler = (e, data) => {
        // console.log(e.target.value, data.id);

        //copy the input object from the state
        const updatedInput = { ...specs.input }

        //copy the specific field like density, maxPower using data.id from updatedInput
        let item = updatedInput[data.id];

        //update the value using the value from onChange to the related field
        item = { ...item, value: e.target.value };

        //update the field item with updated value to updatedInput
        updatedInput[data.id] = item;

         //The data is calculated for certain required fields 

         updatedInput.nominalVoltage.value=updatedInput.cellsInSeries.value*3.7

         updatedInput.maxRPM.value=(updatedInput.kvRating.value*updatedInput.nominalVoltage.value)
         updatedInput.maxWorkingRPM.value=(updatedInput.estimatedMaxPercent.value)/100*updatedInput.maxRPM.value
 
    
        //set the new state
        setSpecs({ input: updatedInput });



    }
  
    const environmentChangeHandler = (e, data) => {
        // console.log(e.target.value, data.id);

        //copy the input object from the state
        const updatedInput = { ...environment.input }

        //copy the specific field like density, maxPower using data.id from updatedInput
        let item = updatedInput[data.id];

        //update the value using the value from onChange to the related field
        item = { ...item, value: e.target.value };

        //update the field item with updated value to updatedInput
        updatedInput[data.id] = item;

        //set the new state
        setEnvironment({ input: updatedInput });
    }

    const diameterChangeHandler = (e, data) => {
        // console.log(e.target.value, data.id);

        //copy the input object from the state
        const updatedInput = { ...diameter.input }

        //copy the specific field like density, maxPower using data.id from updatedInput
        let item = updatedInput[data.id];

        //update the value using the value from onChange to the related field
        item = { ...item, value: e.target.value };

           //Diameter1 value calculation start
         // let powerData=(updatedInput.cp1.value*updatedInput.density.value*Math.pow(updatedInput.maxWorkingRPM.value/60,3))
         let diameter1Result=Math.pow((specs.input.maxPower.value/(updatedInput.cp1.value*environment.input.density.value* Math.pow((specs.input.maxWorkingRPM.value/60),3))),1/5)*1000/25.4
         let diameter2Result=Math.pow((specs.input.maxPower.value/(updatedInput.cp2.value*environment.input.density.value* Math.pow((specs.input.maxWorkingRPM.value/60),3))),1/5)*1000/25.4
        console.log(specs.input.kvRating.value,"specsvalue")
        console.log(environment.input.density.value,"envirovalue")
        console.log(updatedInput.cp2.value,"diametervalue")
        console.log(updatedInput.cp1.value,"diameter1value")
 
         updatedInput.diameter1.value=diameter1Result
         updatedInput.diameter2.value=diameter2Result
 

        //update the field item with updated value to updatedInput
        updatedInput[data.id] = item;

        //set the new state
        setDiameter({ input: updatedInput });
    }


    
        let specsInputData = []
        for (let key in specs.input) {
            specsInputData.push({ id: key, data: specs.input[key] })
        }
        let environmentInputData = []
        for (let key in environment.input) {
            environmentInputData.push({ id: key, data: environment.input[key] })
        }
        let diameterInputData = []
        for (let key in diameter.input) {
            diameterInputData.push({ id: key, data: diameter.input[key] })
        }

        useEffect(
            ()=>{
                
                const updatedDiameterInput = { ...diameter.input }
                const updatedEnvironmentInput={...environment.input}
                const updatedSpecsInput={...specs.input}

                let diameter1Result=Math.pow((updatedSpecsInput.maxPower.value/(updatedDiameterInput.cp1.value*updatedEnvironmentInput.density.value* Math.pow((updatedSpecsInput.maxWorkingRPM.value/60),3))),1/5)*1000/25.4

                let diameter2Result=Math.pow((updatedSpecsInput.maxPower.value/(updatedDiameterInput.cp2.value*updatedEnvironmentInput.density.value* Math.pow((updatedSpecsInput.maxWorkingRPM.value/60),3))),1/5)*1000/25.4
                    updatedDiameterInput.diameter1.value=diameter1Result
                    updatedDiameterInput.diameter2.value=diameter2Result
                    // copy the specific field like density, maxPower using data.id from updatedInput
                    setDiameter({ input: updatedDiameterInput });
                    console.log("updated diameter")
            
                    },[specs])
        console.log('specsData',specsInputData,'environmentData:',environmentInputData,'diameterData', diameterInputData)
        // const classes = useStyles();
        console.log(specs,"state")
        return (
            <div style={{ margin: '0px 20px' }}>

                <div style={{marginTop: '20px'}}>
                    <Typography variant='h5' style={{ margin: '12px', textAlign: 'center' }} >Specs</Typography>
                    <div style={{ flexGrow: 1 }}>
                        <Paper className="paper" style={{ padding: '20px 30px' }}>
                            <Grid container spacing={0}>


                                {specsInputData.map(eachInputData => {
                                    return (
                                        <Grid item xs={6}>
                                            <InputUnit key={eachInputData.id} id={eachInputData.id} data={eachInputData.data} onChange={(e) => specsChangeHandler(e, eachInputData)} />
                                        </Grid>
                                    )
                                })}

                            </Grid>
                        </Paper>
                    </div>
                </div>
                <div style={{margin: '20px 0px'}}>
                    <Typography variant='h5' style={{ margin: '12px', textAlign: 'center' }} >Environment</Typography>

                    <Paper className="paper" style={{ padding: '0px 20px' }}>
                        <Grid container>
                            {environmentInputData.map(eachInputData => {
                                return (
                                    <Grid item xs={6} md={6} lg={6}>
                                        <InputUnit key={eachInputData.id} id={eachInputData.id} data={eachInputData.data} onChange={(e) => environmentChangeHandler(e, eachInputData)} />
                                    </Grid>
                                )
                            })}
                        </Grid>
                    </Paper>
                </div>

                <div style={{margin: '20px 0px'}}>
                    <Typography variant='h5' style={{ margin: '12px', textAlign: 'center' }} >Propeller and Diameter Selection</Typography>

                    <Paper className="paper" style={{ padding: '0px 20px' }}>
                        <Grid container>
                            {diameterInputData.map(eachInputData => {
                                return (
                                    <Grid item xs={6} md={6} lg={6}>
                                        <InputUnit key={eachInputData.id} id={eachInputData.id} data={eachInputData.data} onChange={(e) => diameterChangeHandler(e, eachInputData)} />
                                    </Grid>
                                )
                            })}
                        </Grid>
                    </Paper>
                </div>
            </div>
        )
    }

export default InputContainer;


const sizing={
    missionRequirement:{
        range:{
            value:108,
            unit:'km',
            input:true,
            field:'Range',
            name:'range'
        },
        flightTime:{
            value:1.24,
            unit:'hr',
            input:true,
            field:'Flight Time',
            name:'flightTime'
        },
        payload:{
            value:1.5,
            unit:'kg',
            input:true,
            field:'Payload',
            name:'payload'
        }
    },
    operatingEnvironment:{
        altitude:{
            value:2500,
            unit:'m',
            input:true,
            field:'Altitude',
            name:'altitude'
        },
        airDensity:{
            value:0.9,
            unit:'kg/m^3',
            input:true,
            field:'Air Density',
            name:'airDensity'
        },
        acceleration:{
            value:9.81,
            unit:'m/s^2',
            input:false,
            field:'Acceleration',
            name:'acceleration'
        },
        cruiseSpeed:{
            value:20,
            unit:'m/s',
            input:true,
            field:'Cruise Speed',
            name:'cruiseSpeed'
        },
        stallSpeed:{
            value:15,
            unit:'m/s',
            input:true,
            field:'Stall Speed',
            name:'stallSpeed'
        }
    },
    mass:{
        totalMass:{
            value:12,
            unit:'kg',
            input:true,
            field:'Total Mass',
            name:'totalMass'
        },
        batteryMass:{
            value:3.85,
            unit:'kg',
            input:true,
            field:'Battery Mass',
            name:'batteryMass'
        }
    },
    Wing:{
        span:{
            value:2.6,
            unit:'m',
            input:true,
            field:'Wing',
            name:'wing'
        },
        aspectRatio:{
            value:8,
            unit:'',
            input:true,
            field:'Aspect ratio',
            name:'aspectRatio'
        },
        inducedDragFactor:{
            value:0.04,
            input:true,
            unit:"",
            field:'Induced Drag Factor',
            name:"inducedDragFactor"
        },
        tapperRatio:{
            value:0.04,
            unit:'',
            input:true,
            field:'Tapper Ratio',
            name:'tapperRatio'
        }
    }
}









let data=sizingArray.map((parent,index)=>{
    
    console.log(parent,"parent")
// return <h1>Header</h1>
let arr=
parent.data.map((child,index)=>{
    
console.log(child.data,'parentchild')
return(
    <Grid  items xs={6} style={{margin:'20px 0'}} >
    <Paper elevation={4} className="paper" style={{ padding: '20px 30px',marginLeft:' 20px',marginRight:'10px' }}>
        <div style={{marginTop: '20px'}}>
           <Typography variant='h5' style={{ marginBottom: '12px', textAlign: 'center' }} >Motor Specs</Typography>
                <div style={{ flexGrow: 1 }}>        
                       <Grid item xs={12}>
         <InputUnit key={child.data.name} id={child.data.name} data={child.data} onchange={(e)=>sizingChangeHandler(e,child.data)} />
                           {/* <InputUnit key={eachInputData.id} id={eachInputData.id} data={eachInputData.data} onChange={(e) => sizingChangeHandler(e, eachInputData.data)} /> */}
                       </Grid>
                   </div>         
                  </div>
             </Paper>
           </Grid>
    )

})
return arr
})


console.log(data,"datta")



 //copy the input object from the state
        const updatedInput = { ...specs.input }

        //copy the specific field like density, maxPower using data.id from updatedInput
        let item = updatedInput[data.id];

        //update the value using the value from onChange to the related field
        item = { ...item, value: e.target.value };

        //update the field item with updated value to updatedInput
        updatedInput[data.id] = item;

         //The data is calculated for certain required fields 

         updatedInput.nominalVoltage.value=updatedInput.cellsInSeries.value*3.7

         updatedInput.maxRPM.value=(updatedInput.kvRating.value*updatedInput.nominalVoltage.value)
         updatedInput.maxWorkingRPM.value=(updatedInput.estimatedMaxPercent.value)/100*updatedInput.maxRPM.value

 
         console.log(updatedInput.kvRating.value,"kvcheck")
    
        //set the new state
        setSpecs({ input: updatedInput });




updatedSizing.calculatedWing.wingArea.value=Math.pow(updatedSizing.wing.span.value,2)/updatedSizing.wing.aspectRatio.value;
    updatedSizing.calculatedWing.rootChord.value=2*updatedSizing.calculatedWing.wingArea.value/(updatedSizing.wing.span.value*(1+updatedSizing.wing.tapperRatio.value));
    updatedSizing.calculatedWing.tipChord.value=(updatedSizing.calculatedWing.rootChord.value*updatedSizing.wing.tapperRatio.value);
     updatedSizing.calculatedWing.meanAerodynamicChord.value=(1+updatedSizing.wing.tapperRatio.value+Math.pow(updatedSizing.wing.tapperRatio.value,2))/(1+updatedSizing.wing.tapperRatio.value)*2/3*updatedSizing.calculatedWing.rootChord.value;
     updatedSizing.calculatedHorizontalTail.sht.value=updatedSizing.horizontalTail.cht.value*updatedSizing.calculatedWing.wingArea.value*updatedSizing.calculatedWing.meanAerodynamicChord.value/updatedSizing.horizontalTail.lht.value;
     updatedSizing.calculatedHorizontalTail.rootChord.value=(2*updatedSizing.calculatedHorizontalTail.sht.value/updatedSizing.horizontalTail.span.value)/(1+updatedSizing.horizontalTail.tapperRatio.value);
     updatedSizing.calculatedHorizontalTail.tipChord.value=updatedSizing.calculatedHorizontalTail.rootChord.value*updatedSizing.horizontalTail.tapperRatio.value;
     updatedSizing.calculatedVerticalTail.svt.value=updatedSizing.calculatedWing.wingArea.value*updatedSizing.wing.span.value*updatedSizing.verticalTail.cvt.value/updatedSizing.verticalTail.lvt.value;
     updatedSizing.calculatedVerticalTail.rootChord.value=(updatedSizing.calculatedVerticalTail.svt.value*2/updatedSizing.verticalTail.span.value)/(1+updatedSizing.verticalTail.tapperRatio.value);
     updatedSizing.calculatedVerticalTail.tipChord.value=updatedSizing.calculatedVerticalTail.rootChord.value*updatedSizing.verticalTail.tapperRatio.value;
     updatedSizing.general.massFraction.value=(updatedSizing.missionRequirement.payload.value+updatedSizing.mass.batteryMass.value)/updatedSizing.mass.totalMass.value*100;
     updatedSizing.general.ostwaldEfficiency.value=1/(1+updatedSizing.wing.inducedDragFactor.value)
     updatedSizing.general.k.value=1/(3.14*updatedSizing.general.ostwaldEfficiency.value*updatedSizing.wing.aspectRatio.value)
     updatedSizing.general.minDragAirspeed.value=Math.pow((2*updatedSizing.mass.totalMass.value*updatedSizing.operatingEnvironment.acceleration.value/(updatedSizing.operatingEnvironment.airDensity.value*updatedSizing.calculatedWing.wingArea.value)),0.5)*Math.pow((updatedSizing.general.k.value/(updatedSizing.drag.wingZeroLiftDragCoefficient.value+updatedSizing.drag.fuselageDragCoefficient.value)),0.25);
     updatedSizing.general.minPowerAirspeed.value=Math.pow(1/(3),0.25)*updatedSizing.general.minDragAirspeed.value;
     updatedSizing.general.maxLiftCoefficient.value=updatedSizing.mass.totalMass.value*updatedSizing.operatingEnvironment.acceleration.value/(0.5*updatedSizing.operatingEnvironment.airDensity.value*Math.pow(updatedSizing.operatingEnvironment.stallSpeed.value,2)*updatedSizing.calculatedWing.wingArea.value);
     updatedSizing.general.designLiftCoefficient.value=updatedSizing.mass.totalMass.value*updatedSizing.operatingEnvironment.acceleration.value/(0.5*updatedSizing.operatingEnvironment.airDensity.value*Math.pow(updatedSizing.operatingEnvironment.cruiseSpeed.value,2)*updatedSizing.calculatedWing.wingArea.value);
     updatedSizing.general.inducedDragCoefficient.value=updatedSizing.general.k.value*Math.pow(updatedSizing.general.designLiftCoefficient.value,2)
     updatedSizing.general.totalDragCoefficient.value=updatedSizing.drag.wingZeroLiftDragCoefficient.value+updatedSizing.drag.fuselageDragCoefficient.value+updatedSizing.general.inducedDragCoefficient.value;
     updatedSizing.general.drag.value=(0.5*updatedSizing.operatingEnvironment.airDensity.value*Math.pow(updatedSizing.operatingEnvironment.cruiseSpeed.value,2)*updatedSizing.calculatedWing.wingArea.value*(updatedSizing.general.totalDragCoefficient.value)/updatedSizing.operatingEnvironment.acceleration.value)
     updatedSizing.general.liftToDragRatio.value=updatedSizing.general.designLiftCoefficient.value/updatedSizing.general.inducedDragCoefficient.value;
     updatedSizing.motorAndBattery.maxPower.value=updatedSizing.mass.totalMass.value*updatedSizing.motorAndBattery.powerToWeightRatio.value;
     updatedSizing.motorAndBattery.powerCruise.value=updatedSizing.general.drag.value*updatedSizing.operatingEnvironment.acceleration.value*updatedSizing.operatingEnvironment.cruiseSpeed.value;
     updatedSizing.motorAndBattery.currentCruise.value=(updatedSizing.motorAndBattery.powerCruise.value/updatedSizing.motorAndBattery.nominalVoltage.value)/(updatedSizing.motorAndBattery.propullisiveEfficiency.value/100);
     updatedSizing.motorAndBattery.FlightTime.value=(updatedSizing.missionRequirement.range.value*1000/updatedSizing.operatingEnvironment.cruiseSpeed.value)/(3600);
     updatedSizing.motorAndBattery.rangeBatteryCapacity.value=(updatedSizing.motorAndBattery.FlightTime.value * updatedSizing.motorAndBattery.currentCruise.value/Math.pow(10,-3))/(updatedSizing.motorAndBattery.maximumDischarge.value/100);
     updatedSizing.motorAndBattery.rangeCruiseSpeed.value=updatedSizing.missionRequirement.flightTime.value*60*60*updatedSizing.operatingEnvironment.cruiseSpeed.value/1000;
     updatedSizing.motorAndBattery.flightTimeBatteryCapacity.value=(updatedSizing.missionRequirement.flightTime.value * updatedSizing.motorAndBattery.currentCruise.value/Math.pow(10,-3))/(updatedSizing.motorAndBattery.maximumDischarge.value/100);
     updatedSizing.motorAndBattery.capacityOfEachCell.value=updatedSizing.motorAndBattery.batteryCapacityParallel.value/updatedSizing.motorAndBattery.parallelCells.value;
     updatedSizing.motorAndBattery.cRating.value=updatedSizing.motorAndBattery.maxContinousCurrent.value/(updatedSizing.motorAndBattery.capacityOfEachCell.value/1000);





      let data={
            labels:this.props.label,
            datasets:[{
                label:'Variation of drag force with velocity',
                data:this.props.drag,
                backgroundColor:['rgba(162, 211, 235, 0.4)','red','blue','green','orange'],
                borderWidth:4,
                fill:true,
                radius:4,
                lineTension:0.5
            },
        ]
        }